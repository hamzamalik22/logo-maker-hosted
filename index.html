<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Ghetch Logo Maker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #e5e7eb;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .dark {
      background: #1f1f1f;
    }
    .dark #canvas-wrapper {
      background: #2d2d2d;
    }
    .dark .checker { background-color: #3d3d3d; }

    #canvas-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none;
    }

    #canvas-wrapper {
      position: relative;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      overflow: hidden;
    }

    #canvas-wrapper.transparent-bg {
      background-image: 
        linear-gradient(45deg, #d1d5db 25%, transparent 25%),
        linear-gradient(-45deg, #d1d5db 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #d1d5db 75%),
        linear-gradient(-45deg, transparent 75%, #d1d5db 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    canvas { display: block; }

    #loading {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }

    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #d1d5db;
      border-top-color: #5956E9;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #status {
      margin-top: 16px;
      font-size: 13px;
      color: #6b7280;
    }

    .error {
      color: #ef4444 !important;
      text-align: center;
      padding: 0 20px;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div id="status">Initializing...</div>
  </div>
  
  <div id="canvas-container">
    <div id="canvas-wrapper">
      <canvas id="logo-canvas"></canvas>
    </div>
  </div>

  <!-- Load Fabric.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  
  <script>
    (function() {
      'use strict';

      const statusEl = document.getElementById('status');
      const loadingEl = document.getElementById('loading');

      function updateStatus(msg, isError) {
        statusEl.textContent = msg;
        if (isError) statusEl.classList.add('error');
        sendToRN({ type: 'STATUS', payload: { message: msg, isError } });
      }

      // Check if Fabric loaded
      if (typeof fabric === 'undefined') {
        updateStatus('Failed to load Fabric.js library', true);
        sendToRN({ type: 'LOAD_ERROR', payload: { error: 'Fabric.js not loaded' } });
        return;
      }

      updateStatus('Library loaded, initializing canvas...');

      let canvas = null;
      let historyStack = [];
      let historyIndex = -1;
      const MAX_HISTORY = 50;
      let backgroundRect = null;
      let canvasWidth = 280;
      let canvasHeight = 280;
      let currentZoom = 1;

      // Alignment & snapping guides
      const SNAP_THRESHOLD = 6; // px
      let hGuideLines = [];
      let vGuideLines = [];

      // Pen Tool
      let penTool = null;
      let penToolActive = false;
      let penToolMode = 'shape'; // 'shape' or 'path'

      function initCanvas() {
        try {
          const container = document.getElementById('canvas-container');
          const wrapper = document.getElementById('canvas-wrapper');
          
          const maxWidth = container.clientWidth - 40;
          const maxHeight = container.clientHeight - 40;
          canvasWidth = Math.min(280, maxWidth);
          canvasHeight = Math.min(280, maxHeight);

          wrapper.style.width = canvasWidth + 'px';
          wrapper.style.height = canvasHeight + 'px';

          canvas = new fabric.Canvas('logo-canvas', {
            width: canvasWidth,
            height: canvasHeight,
            backgroundColor: '#ffffff',
            selection: true,
            preserveObjectStacking: true,
          });

          setupEventListeners();
          createBackground('#ffffff');
          saveHistory();

          loadingEl.classList.add('hidden');
          sendToRN({ type: 'CANVAS_READY', payload: { width: canvasWidth, height: canvasHeight } });
          
        } catch (error) {
          updateStatus('Error: ' + error.message, true);
          sendToRN({ type: 'LOAD_ERROR', payload: { error: error.message } });
        }
      }

      function setupEventListeners() {
        canvas.on('selection:created', handleSelection);
        canvas.on('selection:updated', handleSelection);
        canvas.on('selection:cleared', () => sendToRN({ type: 'SELECTION_CLEARED' }));
        canvas.on('object:modified', () => { 
          clearGuides();
          saveHistory(); 
          sendSelectionUpdate(); 
        });
        canvas.on('object:added', (e) => { if (e.target?.objectId !== 'background_layer') saveHistory(); });
        canvas.on('object:removed', (e) => { if (e.target?.objectId !== 'background_layer') saveHistory(); });
        canvas.on('object:moving', handleObjectMoving);
        canvas.on('mouse:up', (e) => {
          clearGuides();
          if (penToolActive && penTool) {
            penTool.handleMouseUp(e);
          }
        });
        canvas.on('mouse:down', (e) => {
          if (penToolActive && penTool) {
            penTool.handleMouseDown(e);
          }
        });
        canvas.on('mouse:move', (e) => {
          if (penToolActive && penTool) {
            penTool.handleMouseMove(e);
          }
        });
      }

      function createBackground(color) {
        if (backgroundRect) canvas.remove(backgroundRect);
        const wrapper = document.getElementById('canvas-wrapper');

        if (color === 'transparent') {
          wrapper.classList.add('transparent-bg');
          canvas.backgroundColor = 'transparent';
          backgroundRect = null;
        } else {
          wrapper.classList.remove('transparent-bg');
          backgroundRect = new fabric.Rect({
            left: 0, top: 0,
            width: canvasWidth, height: canvasHeight,
            fill: color,
            selectable: false, evented: false,
            objectId: 'background_layer',
          });
          canvas.add(backgroundRect);
          backgroundRect.sendToBack();
          canvas.backgroundColor = '#ffffff';
        }
        canvas.renderAll();
      }

      function addShape(type, options = {}) {
        let shape;
        const cx = canvasWidth / 2, cy = canvasHeight / 2;
        const defaults = { left: cx, top: cy, originX: 'center', originY: 'center', ...options };

        switch (type) {
          case 'rectangle':
            shape = new fabric.Rect({ ...defaults, width: 80, height: 80, fill: options.fill || '#3b82f6' });
            break;
          case 'circle':
            shape = new fabric.Circle({ ...defaults, radius: 40, fill: options.fill || '#10b981' });
            break;
          case 'triangle':
            shape = new fabric.Triangle({ ...defaults, width: 80, height: 80, fill: options.fill || '#f59e0b' });
            break;
          case 'line':
            shape = new fabric.Line([cx - 40, cy, cx + 40, cy], { stroke: options.stroke || '#000', strokeWidth: 3 });
            break;
          case 'star':
            const pts = [];
            for (let i = 0; i < 10; i++) {
              const r = i % 2 === 0 ? 40 : 20;
              const a = (Math.PI / 5) * i - Math.PI / 2;
              pts.push({ x: r * Math.cos(a), y: r * Math.sin(a) });
            }
            shape = new fabric.Polygon(pts, { ...defaults, fill: options.fill || '#8b5cf6' });
            break;
          case 'polygon':
            const sides = options.sides || 5, polyPts = [];
            for (let i = 0; i < sides; i++) {
              const a = (2 * Math.PI / sides) * i - Math.PI / 2;
              polyPts.push({ x: 40 * Math.cos(a), y: 40 * Math.sin(a) });
            }
            shape = new fabric.Polygon(polyPts, { ...defaults, fill: options.fill || '#ec4899' });
            break;
          default: return;
        }

        shape.objectId = 'shape_' + Date.now();
        shape.set({
          cornerColor: '#5956E9', cornerStrokeColor: '#5956E9', borderColor: '#5956E9',
          cornerSize: 10, cornerStyle: 'circle', transparentCorners: false, borderScaleFactor: 2,
        });
        canvas.add(shape);
        canvas.setActiveObject(shape);
        canvas.renderAll();
        sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(shape) });
      }

      function addText(text, options = {}) {
        const textObj = new fabric.IText(text || 'Your Text', {
          left: canvasWidth / 2, top: canvasHeight / 2,
          originX: 'center', originY: 'center',
          fontSize: options.fontSize || 32,
          fontFamily: options.fontFamily || 'Arial',
          fontWeight: options.fontWeight || 'normal',
          fill: options.fill || '#000000',
          textAlign: 'center',
          objectId: 'text_' + Date.now(),
          cornerColor: '#5956E9', cornerStrokeColor: '#5956E9', borderColor: '#5956E9',
          cornerSize: 10, cornerStyle: 'circle', transparentCorners: false,
        });
        canvas.add(textObj);
        canvas.setActiveObject(textObj);
        canvas.renderAll();
        sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(textObj) });
      }

      function addSVG(svgString) {
        fabric.loadSVGFromString(svgString, (objects, opts) => {
          const group = fabric.util.groupSVGElements(objects, opts);
          const scale = Math.min(80 / group.width, 80 / group.height);
          group.set({
            left: canvasWidth / 2, top: canvasHeight / 2,
            originX: 'center', originY: 'center',
            scaleX: scale, scaleY: scale,
            objectId: 'svg_' + Date.now(),
            cornerColor: '#5956E9', cornerStrokeColor: '#5956E9', borderColor: '#5956E9',
            cornerSize: 10, cornerStyle: 'circle', transparentCorners: false,
          });
          canvas.add(group);
          canvas.setActiveObject(group);
          canvas.renderAll();
          sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(group) });
        });
      }

      function addImage(dataUrl, options = {}) {
        if (!dataUrl) return;
        try {
          fabric.Image.fromURL(
            dataUrl,
            (img) => {
              if (!img) return;

              const maxW = Math.max(50, canvasWidth * 0.7);
              const maxH = Math.max(50, canvasHeight * 0.7);
              const iw = img.width || 1;
              const ih = img.height || 1;
              const scale = Math.min(maxW / iw, maxH / ih, 1);

              img.set({
                left: canvasWidth / 2,
                top: canvasHeight / 2,
                originX: 'center',
                originY: 'center',
                scaleX: scale,
                scaleY: scale,
                objectId: 'image_' + Date.now(),
                ...options,
                cornerColor: '#5956E9',
                cornerStrokeColor: '#5956E9',
                borderColor: '#5956E9',
                cornerSize: 10,
                cornerStyle: 'circle',
                transparentCorners: false,
              });

              canvas.add(img);
              canvas.setActiveObject(img);
              canvas.renderAll();
              saveHistory();
              sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(img) });
            },
            { crossOrigin: 'anonymous' }
          );
        } catch (e) {
          sendToRN({ type: 'CONSOLE_ERROR', payload: { message: 'addImage failed: ' + (e?.message || String(e)) } });
        }
      }

      function updateSelectedObject(prop, val) {
        const obj = canvas.getActiveObject();
        if (!obj) return;
        if (prop === 'fontSize') val = parseInt(val);
        else if (prop === 'strokeWidth') val = parseFloat(val);
        obj.set(prop, val);
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function nudgePosition(deltaX, deltaY) {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        obj.set({ 
          left: obj.left + deltaX, 
          top: obj.top + deltaY 
        });
        obj.setCoords();
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function setScale(scaleX, scaleY) {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        obj.set({ 
          scaleX: scaleX, 
          scaleY: scaleY || scaleX 
        });
        obj.setCoords();
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      // Canvas zoom helpers
      function setCanvasZoom(zoom) {
        if (!canvas) return;
        const clamped = Math.max(0.5, Math.min(3, zoom || 1));
        const center = new fabric.Point(canvasWidth / 2, canvasHeight / 2);
        canvas.zoomToPoint(center, clamped);
        currentZoom = clamped;
        canvas.renderAll();
        sendToRN({ type: 'CANVAS_ZOOM', payload: { zoom: currentZoom } });
      }

      function zoomIn(step) {
        const delta = typeof step === 'number' ? step : 0.1;
        setCanvasZoom(currentZoom + delta);
      }

      function zoomOut(step) {
        const delta = typeof step === 'number' ? step : 0.1;
        setCanvasZoom(currentZoom - delta);
      }

      function rotateObject(angleDelta) {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        obj.set({ angle: (obj.angle || 0) + angleDelta });
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      // --- Alignment helpers (canvas center + snapping guides) ---

      function alignCenterHorizontal() {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        const center = obj.getCenterPoint();
        const newCenter = new fabric.Point(canvasWidth / 2, center.y);
        obj.setPositionByOrigin(newCenter, 'center', 'center');
        obj.setCoords();
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function alignCenterVertical() {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        const center = obj.getCenterPoint();
        const newCenter = new fabric.Point(center.x, canvasHeight / 2);
        obj.setPositionByOrigin(newCenter, 'center', 'center');
        obj.setCoords();
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function alignLeft() {
        const activeSelection = canvas.getActiveObject();
        if (!activeSelection || activeSelection.objectId === 'background_layer') return;

        if (activeSelection.type === 'activeselection' && activeSelection.getObjects().length >= 2) {
          // Multiple objects: align to left edge of selection bounds
          const bounds = activeSelection.getBoundingRect();
          const objects = activeSelection.getObjects();
          objects.forEach(obj => {
            obj.set({ left: bounds.left });
            obj.setCoords();
          });
        } else {
          // Single object: align to left edge of canvas
          const obj = activeSelection;
          const left = 0;
          obj.set({ left: left });
          obj.setCoords();
        }
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function alignRight() {
        const activeSelection = canvas.getActiveObject();
        if (!activeSelection || activeSelection.objectId === 'background_layer') return;

        if (activeSelection.type === 'activeselection' && activeSelection.getObjects().length >= 2) {
          // Multiple objects: align to right edge of selection bounds
          const bounds = activeSelection.getBoundingRect();
          const objects = activeSelection.getObjects();
          objects.forEach(obj => {
            obj.set({ left: bounds.left + bounds.width - obj.getScaledWidth() });
            obj.setCoords();
          });
        } else {
          // Single object: align to right edge of canvas
          const obj = activeSelection;
          const left = canvasWidth - obj.getScaledWidth();
          obj.set({ left: left });
          obj.setCoords();
        }
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function alignTop() {
        const activeSelection = canvas.getActiveObject();
        if (!activeSelection || activeSelection.objectId === 'background_layer') return;

        if (activeSelection.type === 'activeselection' && activeSelection.getObjects().length >= 2) {
          // Multiple objects: align to top edge of selection bounds
          const bounds = activeSelection.getBoundingRect();
          const objects = activeSelection.getObjects();
          objects.forEach(obj => {
            obj.set({ top: bounds.top });
            obj.setCoords();
          });
        } else {
          // Single object: align to top edge of canvas
          const obj = activeSelection;
          const top = 0;
          obj.set({ top: top });
          obj.setCoords();
        }
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function alignBottom() {
        const activeSelection = canvas.getActiveObject();
        if (!activeSelection || activeSelection.objectId === 'background_layer') return;

        if (activeSelection.type === 'activeselection' && activeSelection.getObjects().length >= 2) {
          // Multiple objects: align to bottom edge of selection bounds
          const bounds = activeSelection.getBoundingRect();
          const objects = activeSelection.getObjects();
          objects.forEach(obj => {
            obj.set({ top: bounds.top + bounds.height - obj.getScaledHeight() });
            obj.setCoords();
          });
        } else {
          // Single object: align to bottom edge of canvas
          const obj = activeSelection;
          const top = canvasHeight - obj.getScaledHeight();
          obj.set({ top: top });
          obj.setCoords();
        }
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      // --- Pen Tool Implementation ---

      class PenTool {
        constructor() {
          this.isActive = false;
          this.mode = 'shape'; // 'shape' or 'path'
          this.points = [];
          this.tempLines = [];
          this.tempCircles = [];
          this.pathPoints = [];
          this.pathLines = [];
          this.controlCircles = [];
          this.currentPathObject = null;
          this.isDraggingPoint = false;
          this.draggedPointIndex = -1;
          this.previewLine = null;
        }

        setMode(mode) {
          if (this.mode !== mode) {
            this.cleanup();
            this.mode = mode;
          }
        }

        activate() {
          this.isActive = true;
          this.cleanup();
          penToolActive = true;
          canvas.defaultCursor = 'crosshair';
          canvas.hoverCursor = 'crosshair';
          canvas.selection = false;
          canvas.forEachObject((obj) => {
            if (obj.objectId !== 'background_layer') {
              obj.selectable = false;
              obj.evented = false;
            }
          });
          canvas.renderAll();
        }

        deactivate() {
          this.isActive = false;
          this.cleanup();
          penToolActive = false;
          canvas.defaultCursor = 'default';
          canvas.hoverCursor = 'move';
          canvas.selection = true;
          canvas.forEachObject((obj) => {
            if (obj.objectId !== 'background_layer') {
              obj.selectable = true;
              obj.evented = true;
            }
          });
          canvas.renderAll();
        }

        cleanup() {
          this.tempCircles.forEach(circle => {
            try { canvas.remove(circle); } catch (e) {}
          });
          this.tempLines.forEach(line => {
            try { canvas.remove(line); } catch (e) {}
          });
          this.controlCircles.forEach(circle => {
            try { canvas.remove(circle); } catch (e) {}
          });
          this.pathLines.forEach(line => {
            try { canvas.remove(line); } catch (e) {}
          });
          if (this.previewLine) {
            try { canvas.remove(this.previewLine); } catch (e) {}
            this.previewLine = null;
          }
          if (this.currentPathObject) {
            try { canvas.remove(this.currentPathObject); } catch (e) {}
            this.currentPathObject = null;
          }
          this.tempCircles = [];
          this.tempLines = [];
          this.points = [];
          this.pathPoints = [];
          this.controlCircles = [];
          this.pathLines = [];
          this.isDraggingPoint = false;
          this.draggedPointIndex = -1;
          canvas.renderAll();
        }

        handleMouseDown(event) {
          if (!this.isActive) return;
          if (event.e) event.e.preventDefault();
          const pointer = canvas.getPointer(event.e);

          if (this.mode === 'path') {
            this.handlePathModeMouseDown(pointer);
          } else {
            this.handleShapeModeMouseDown(pointer);
          }
        }

        handleShapeModeMouseDown(pointer) {
          if (this.points.length > 2) {
            const firstPoint = this.points[0];
            const distance = Math.sqrt(
              Math.pow(pointer.x - firstPoint.x, 2) + Math.pow(pointer.y - firstPoint.y, 2)
            );
            if (distance < 15) {
              this.finalizeShapePath(true);
              return;
            }
          }
          this.addShapePoint(pointer);
        }

        handlePathModeMouseDown(pointer) {
          if (this.pathPoints.length > 0) {
            for (let i = 0; i < this.pathPoints.length; i++) {
              const point = this.pathPoints[i];
              const distance = Math.sqrt(
                Math.pow(pointer.x - point.x, 2) + Math.pow(pointer.y - point.y, 2)
              );
              if (distance < 12) {
                this.isDraggingPoint = true;
                this.draggedPointIndex = i;
                return;
              }
            }
          }
          if (this.pathPoints.length >= 6) return;
          this.addPathPoint(pointer);
        }

        addPathPoint(pointer) {
          const point = { x: pointer.x, y: pointer.y };
          this.pathPoints.push(point);
          const circle = new fabric.Circle({
            left: point.x, top: point.y, radius: 8,
            fill: '#5956E9', stroke: '#ffffff', strokeWidth: 3,
            selectable: false, evented: false, hasControls: false, hasBorders: false,
            originX: 'center', originY: 'center',
            objectId: `path_control_${this.pathPoints.length}`
          });
          canvas.add(circle);
          this.controlCircles.push(circle);
          if (this.pathPoints.length >= 2) {
            this.updatePathVisualization();
          }
          canvas.renderAll();
        }

        updatePathVisualization() {
          this.pathLines.forEach(line => canvas.remove(line));
          this.pathLines = [];
          if (this.currentPathObject) {
            canvas.remove(this.currentPathObject);
            this.currentPathObject = null;
          }
          for (let i = 0; i < this.pathPoints.length - 1; i++) {
            const p1 = this.pathPoints[i];
            const p2 = this.pathPoints[i + 1];
            const line = new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
              stroke: '#000000', strokeWidth: 3, selectable: false, evented: false,
              strokeLineCap: 'round', objectId: `path_line_${i}`
            });
            canvas.add(line);
            this.pathLines.push(line);
          }
          this.controlCircles.forEach(circle => canvas.bringToFront(circle));
          canvas.renderAll();
        }

        handleMouseMove(event) {
          if (!this.isActive) return;
          const pointer = canvas.getPointer(event.e);

          if (this.mode === 'path') {
            this.handlePathModeMouseMove(pointer);
          } else {
            this.handleShapeModeMouseMove(pointer);
          }
        }

        handleShapeModeMouseMove(pointer) {
          if (this.points.length === 0) return;
          if (this.previewLine) {
            canvas.remove(this.previewLine);
            this.previewLine = null;
          }
          const lastPoint = this.points[this.points.length - 1];
          this.previewLine = new fabric.Line(
            [lastPoint.x, lastPoint.y, pointer.x, pointer.y],
            { stroke: '#5956E9', strokeWidth: 2, strokeDashArray: [5, 5],
              selectable: false, evented: false, opacity: 0.6, objectId: 'preview_line' }
          );
          canvas.add(this.previewLine);
          canvas.renderAll();
        }

        handlePathModeMouseMove(pointer) {
          if (this.isDraggingPoint && this.draggedPointIndex >= 0) {
            this.pathPoints[this.draggedPointIndex] = { x: pointer.x, y: pointer.y };
            const circle = this.controlCircles[this.draggedPointIndex];
            if (circle) {
              circle.set({ left: pointer.x, top: pointer.y });
            }
            this.updatePathVisualization();
            canvas.renderAll();
            return;
          }
          if (this.pathPoints.length > 0 && this.pathPoints.length < 6) {
            if (this.previewLine) {
              canvas.remove(this.previewLine);
              this.previewLine = null;
            }
            const lastPoint = this.pathPoints[this.pathPoints.length - 1];
            this.previewLine = new fabric.Line(
              [lastPoint.x, lastPoint.y, pointer.x, pointer.y],
              { stroke: '#5956E9', strokeWidth: 2, strokeDashArray: [5, 5],
                selectable: false, evented: false, opacity: 0.6, objectId: 'preview_line' }
            );
            canvas.add(this.previewLine);
            canvas.renderAll();
          }
        }

        handleMouseUp(event) {
          if (!this.isActive) return;
          if (this.mode === 'path' && this.isDraggingPoint) {
            this.isDraggingPoint = false;
            this.draggedPointIndex = -1;
          }
        }

        addShapePoint(pointer) {
          const point = { x: pointer.x, y: pointer.y };
          this.points.push(point);
          const circle = new fabric.Circle({
            left: point.x, top: point.y, radius: 5,
            fill: '#5956E9', stroke: '#ffffff', strokeWidth: 2,
            selectable: false, evented: false, hasControls: false, hasBorders: false,
            originX: 'center', originY: 'center',
            objectId: `point_marker_${this.points.length}`
          });
          canvas.add(circle);
          this.tempCircles.push(circle);
          if (this.points.length > 1) {
            const prevPoint = this.points[this.points.length - 2];
            const line = new fabric.Line([prevPoint.x, prevPoint.y, point.x, point.y], {
              stroke: '#000000', strokeWidth: 2, selectable: false, evented: false,
              objectId: `temp_line_${this.points.length}`
            });
            canvas.add(line);
            this.tempLines.push(line);
          }
          canvas.renderAll();
        }

        finalizeShapePath(closed = false) {
          if (this.points.length < 2) {
            this.cleanup();
            return;
          }
          let pathData = `M ${this.points[0].x} ${this.points[0].y}`;
          for (let i = 1; i < this.points.length; i++) {
            pathData += ` L ${this.points[i].x} ${this.points[i].y}`;
          }
          if (closed) pathData += ' Z';
          if (this.previewLine) {
            canvas.remove(this.previewLine);
            this.previewLine = null;
          }
          const path = new fabric.Path(pathData, {
            fill: closed ? '#b3b3b3' : 'transparent',
            stroke: '#000000', strokeWidth: 2,
            objectCaching: false, selectable: true, evented: true,
            cornerStrokeColor: "#b3b3b3", cornerStyle: "circle", cornerSize: 10,
            transparentCorners: false, borderColor: "#5956E9", borderScaleFactor: 1,
            objectId: 'pen_shape_' + Date.now(), type: 'pen-shape'
          });
          this.cleanup();
          canvas.add(path);
          canvas.setActiveObject(path);
          canvas.renderAll();
          saveHistory();
          sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(path) });
          // Keep pen tool active for continuous drawing
          // Don't deactivate - allow user to draw multiple shapes
        }

        finalizePathMode() {
          if (this.pathPoints.length < 2) {
            this.cleanup();
            return;
          }
          let pathData = `M ${this.pathPoints[0].x} ${this.pathPoints[0].y}`;
          for (let i = 1; i < this.pathPoints.length; i++) {
            pathData += ` L ${this.pathPoints[i].x} ${this.pathPoints[i].y}`;
          }
          if (this.previewLine) {
            canvas.remove(this.previewLine);
            this.previewLine = null;
          }
          const finalPath = new fabric.Path(pathData, {
            fill: 'transparent', stroke: '#000000', strokeWidth: 3,
            strokeLineCap: 'round', strokeLineJoin: 'round',
            objectCaching: false, selectable: true, evented: true,
            cornerStrokeColor: "#b3b3b3", cornerStyle: "circle", cornerSize: 10,
            transparentCorners: false, borderColor: "#5956E9", borderScaleFactor: 1,
            objectId: 'pen_path_' + Date.now(), type: 'pen-path',
            customType: 'editablePath', pathPoints: [...this.pathPoints]
          });
          this.cleanup();
          canvas.add(finalPath);
          canvas.setActiveObject(finalPath);
          canvas.renderAll();
          saveHistory();
          sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(finalPath) });
          // Keep pen tool active for continuous drawing
          // Don't deactivate - allow user to draw multiple paths
        }
      }

      // Initialize pen tool
      penTool = new PenTool();

      // --- Draw Tool (Freeform Drawing) ---
      let drawToolActive = false;
      let drawToolColor = '#000000';
      let drawToolWidth = 5;

      function activateDrawTool() {
        if (!canvas) return;
        drawToolActive = true;
        canvas.isDrawingMode = true;
        
        if (!canvas.freeDrawingBrush) {
          canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        }
        
        canvas.freeDrawingBrush.width = drawToolWidth;
        canvas.freeDrawingBrush.color = drawToolColor;
        
        // Disable selection while drawing
        canvas.selection = false;
        canvas.forEachObject((obj) => {
          if (obj.objectId !== 'background_layer') {
            obj.selectable = false;
            obj.evented = false;
          }
        });
        
        // Remove existing listener to avoid duplicates
        canvas.off('path:created');
        // Listen for path creation to save history
        canvas.on('path:created', function(e) {
          const path = e.path;
          path.set({
            objectId: 'draw_path_' + Date.now(),
            cornerStrokeColor: "#b3b3b3",
            cornerStyle: "circle",
            cornerSize: 10,
            transparentCorners: false,
            borderColor: "#5956E9",
            borderScaleFactor: 1,
          });
          canvas.setActiveObject(path);
          canvas.renderAll();
          saveHistory();
          sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(path) });
        });
        
        canvas.renderAll();
      }

      function deactivateDrawTool() {
        if (!canvas) return;
        drawToolActive = false;
        canvas.isDrawingMode = false;
        canvas.selection = true;
        canvas.forEachObject((obj) => {
          if (obj.objectId !== 'background_layer') {
            obj.selectable = true;
            obj.evented = true;
          }
        });
        canvas.off('path:created');
        canvas.renderAll();
      }

      function setDrawToolColor(color) {
        drawToolColor = color;
        if (canvas && canvas.freeDrawingBrush) {
          canvas.freeDrawingBrush.color = color;
        }
      }

      function setDrawToolWidth(width) {
        drawToolWidth = width;
        if (canvas && canvas.freeDrawingBrush) {
          canvas.freeDrawingBrush.width = width;
        }
      }

      // --- Snapping guides ---

      function clearGuides() {  
        if (!canvas) return;
        const toRemove = canvas.getObjects().filter(o => o.isGuideLine);
        toRemove.forEach(o => canvas.remove(o));
        hGuideLines = [];
        vGuideLines = [];
        canvas.renderAll();
      }

      function addGuideLine(x1, y1, x2, y2, isVertical) {
        const line = new fabric.Line([x1, y1, x2, y2], {
          stroke: '#5956E9',
          strokeWidth: 1,
          selectable: false,
          evented: false,
          excludeFromExport: true,
          opacity: 0.6,
          strokeDashArray: [4, 4],
          isGuideLine: true,
        });
        canvas.add(line);
        if (isVertical) vGuideLines.push(line);
        else hGuideLines.push(line);
      }

      function handleObjectMoving(e) {
        const target = e.target;
        if (!target || target.objectId === 'background_layer') return;

        clearGuides();

        const center = target.getCenterPoint();
        let snapX = center.x;
        let snapY = center.y;

        const canvasCenterX = canvasWidth / 2;
        const canvasCenterY = canvasHeight / 2;

        // Snap to canvas center
        if (Math.abs(center.x - canvasCenterX) < SNAP_THRESHOLD) {
          snapX = canvasCenterX;
          addGuideLine(canvasCenterX, 0, canvasCenterX, canvasHeight, true);
        }
        if (Math.abs(center.y - canvasCenterY) < SNAP_THRESHOLD) {
          snapY = canvasCenterY;
          addGuideLine(0, canvasCenterY, canvasWidth, canvasCenterY, false);
        }

        // Snap to other object centers
        const objects = canvas.getObjects().filter(o => 
          o !== target && 
          o.objectId !== 'background_layer' && 
          !o.isGuideLine
        );

        objects.forEach(obj => {
          const c = obj.getCenterPoint();

          if (Math.abs(center.x - c.x) < SNAP_THRESHOLD) {
            snapX = c.x;
            addGuideLine(c.x, 0, c.x, canvasHeight, true);
          }
          if (Math.abs(center.y - c.y) < SNAP_THRESHOLD) {
            snapY = c.y;
            addGuideLine(0, c.y, canvasWidth, c.y, false);
          }
        });

        // Apply snapped center back to object position
        if (snapX !== center.x || snapY !== center.y) {
          target.setPositionByOrigin(
            new fabric.Point(snapX, snapY),
            'center',
            'center'
          );
          target.setCoords();
        }

        canvas.renderAll();
        sendSelectionUpdate();
      }

      function deleteSelected() {
        canvas.getActiveObjects().forEach(obj => {
          if (obj.objectId !== 'background_layer') canvas.remove(obj);
        });
        canvas.discardActiveObject();
        canvas.renderAll();
        saveHistory();
        sendToRN({ type: 'SELECTION_CLEARED' });
      }

      function duplicateSelected() {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        obj.clone(cloned => {
          cloned.set({ left: obj.left + 15, top: obj.top + 15, objectId: obj.type + '_' + Date.now() });
          canvas.add(cloned);
          canvas.setActiveObject(cloned);
          canvas.renderAll();
          saveHistory();
        });
      }

      // Grouping helpers
      function groupSelected() {
        const activeObj = canvas.getActiveObject();
        if (!activeObj) return;

        // Fabric creates an ActiveSelection when multiple objects are selected
        if (activeObj.type === 'activeSelection') {
          const group = activeObj.toGroup();
          if (group) {
            // Ensure the group has a stable unique id so layer keys are unique
            if (!group.objectId) {
              group.objectId = 'group_' + Date.now();
            }
            // Ensure background stays at the very back
            if (backgroundRect) {
              backgroundRect.sendToBack();
            }
            canvas.renderAll();
            saveHistory();
            sendSelectionUpdate();
          }
        }
      }

      function ungroupSelected() {
        const activeObj = canvas.getActiveObject();
        if (!activeObj || activeObj.type !== 'group') return;

        const selection = activeObj.toActiveSelection();
        if (selection) {
          // Keep background behind everything
          if (backgroundRect) {
            backgroundRect.sendToBack();
          }
          canvas.renderAll();
          saveHistory();
          sendSelectionUpdate();
        }
      }

      function bringForward() { const o = canvas.getActiveObject(); if (o) { o.bringForward(); canvas.renderAll(); saveHistory(); } }
      function sendBackward() {
        const o = canvas.getActiveObject();
        if (o) {
          const objs = canvas.getObjects();
          const bgIdx = objs.findIndex(x => x.objectId === 'background_layer');
          if (objs.indexOf(o) > bgIdx + 1) { o.sendBackwards(); canvas.renderAll(); saveHistory(); }
        }
      }
      function bringToFront() { const o = canvas.getActiveObject(); if (o) { o.bringToFront(); canvas.renderAll(); saveHistory(); } }
      function sendToBack() {
        const o = canvas.getActiveObject();
        if (o) {
          o.sendToBack();
          if (backgroundRect) backgroundRect.sendToBack();
          canvas.renderAll();
          saveHistory();
        }
      }

      function saveHistory() {
        const json = canvas.toJSON(['objectId']);
        if (historyIndex < historyStack.length - 1) historyStack = historyStack.slice(0, historyIndex + 1);
        historyStack.push(json);
        if (historyStack.length > MAX_HISTORY) historyStack.shift();
        else historyIndex++;
        sendHistoryState();
      }

      function undo() { if (historyIndex > 0) { historyIndex--; loadHistory(); } }
      function redo() { if (historyIndex < historyStack.length - 1) { historyIndex++; loadHistory(); } }

      function loadHistory() {
        const state = historyStack[historyIndex];
        if (!state) return;
        canvas.loadFromJSON(state, () => {
          backgroundRect = canvas.getObjects().find(o => o.objectId === 'background_layer') || null;
          canvas.renderAll();
          sendHistoryState();
          sendToRN({ type: 'SELECTION_CLEARED' });
        });
      }

      function sendHistoryState() {
        sendToRN({ type: 'HISTORY_STATE', payload: { canUndo: historyIndex > 0, canRedo: historyIndex < historyStack.length - 1 } });
      }

      function exportCanvas(format, quality = 1, multiplier = 2) {
        try {
          if (format === 'svg') {
            sendToRN({ type: 'EXPORT_COMPLETE', payload: { format: 'svg', data: canvas.toSVG() } });
            return;
          }
          const dataUrl = canvas.toDataURL({ format: format === 'jpeg' ? 'jpeg' : 'png', quality, multiplier });
          sendToRN({ type: 'EXPORT_COMPLETE', payload: { format, data: dataUrl } });
        } catch (e) {
          sendToRN({ type: 'EXPORT_ERROR', payload: { error: e.message } });
        }
      }

      function getLayerName(obj) {
        if (obj.type === 'i-text' || obj.type === 'text' || obj.type === 'textbox') {
          return obj.text ? obj.text.substring(0, 20) : 'Text';
        }
        if (obj.type === 'rect' || obj.type === 'rectangle') return 'Rectangle';
        if (obj.type === 'circle') return 'Circle';
        if (obj.type === 'triangle') return 'Triangle';
        if (obj.type === 'line') return 'Line';
        if (obj.type === 'polygon') return 'Polygon';
        if (obj.type === 'group') return 'Group';
        if (obj.type === 'image') return 'Image';
        if (obj.type === 'path') return 'Path';
        return obj.type || 'Layer';
      }

      function getLayers() {
        const allObjects = canvas.getObjects().filter(o => o.objectId !== 'background_layer');
        const layers = allObjects
          .map((obj, i) => ({ 
            id: obj.objectId || ('layer_' + i), 
            type: obj.type, 
            name: getLayerName(obj),
            visible: obj.visible !== false, 
            locked: !obj.selectable, 
            index: allObjects.length - i - 1
          }))
          .reverse();
        sendToRN({ type: 'LAYERS_LIST', payload: { layers } });
      }

      function setLayerVisibility(id, visible) {
        const obj = canvas.getObjects().find(o => o.objectId === id);
        if (obj) { obj.set('visible', visible); canvas.renderAll(); saveHistory(); }
      }

      function setLayerLock(id, locked) {
        const obj = canvas.getObjects().find(o => o.objectId === id);
        if (obj && obj.objectId !== 'background_layer') {
          obj.set({ selectable: !locked, evented: !locked });
          canvas.renderAll();
          saveHistory();
        }
      }

      function selectLayer(id) {
        const obj = canvas.getObjects().find(o => o.objectId === id);
        if (obj && obj.selectable) { canvas.setActiveObject(obj); canvas.renderAll(); }
      }

      function handleSelection(e) {
        const sel = e.selected[0];
        if (sel && sel.objectId !== 'background_layer') {
          sendToRN({ type: 'SELECTION_CHANGED', payload: getObjectInfo(sel) });
        }
      }

      function sendSelectionUpdate() {
        const obj = canvas.getActiveObject();
        if (obj && obj.objectId !== 'background_layer') {
          sendToRN({ type: 'SELECTION_CHANGED', payload: getObjectInfo(obj) });
        }
      }

      function getObjectInfo(obj) {
        return {
          objectId: obj.objectId, type: obj.type,
          left: Math.round(obj.left), top: Math.round(obj.top),
          width: Math.round(obj.width * (obj.scaleX || 1)),
          height: Math.round(obj.height * (obj.scaleY || 1)),
          scaleX: obj.scaleX || 1,
          scaleY: obj.scaleY || 1,
          angle: Math.round(obj.angle || 0),
          fill: obj.fill, stroke: obj.stroke, strokeWidth: obj.strokeWidth, opacity: obj.opacity,
          text: obj.text, fontSize: obj.fontSize, fontFamily: obj.fontFamily, fontWeight: obj.fontWeight,
        };
      }

      function sendToRN(msg) {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify(msg));
        } else {
          console.log('RN Message:', msg);
        }
      }

      window.handleRNMessage = function(message) {
        try {
          const { type, payload } = typeof message === 'string' ? JSON.parse(message) : message;
          switch (type) {
            case 'ADD_SHAPE': addShape(payload.shape, payload.options); break;
            case 'ADD_TEXT': addText(payload.text, payload.options); break;
            case 'ADD_SVG': addSVG(payload.svg); break;
            case 'ADD_IMAGE': addImage(payload.dataUrl, payload.options); break;
            case 'PEN_TOOL_ACTIVATE': 
              if (penTool) {
                penTool.setMode(payload?.mode || 'shape');
                penTool.activate();
              }
              break;
            case 'PEN_TOOL_DEACTIVATE': 
              if (penTool) penTool.deactivate(); 
              break;
            case 'PEN_TOOL_SET_MODE': 
              if (penTool) penTool.setMode(payload?.mode || 'shape'); 
              break;
            case 'PEN_TOOL_FINALIZE_SHAPE': 
              if (penTool) penTool.finalizeShapePath(false); 
              break;
            case 'PEN_TOOL_FINALIZE_PATH': 
              if (penTool) penTool.finalizePathMode(); 
              break;
            case 'PEN_TOOL_CANCEL': 
              if (penTool) { penTool.cleanup(); penTool.deactivate(); } 
              break;
            case 'DRAW_TOOL_ACTIVATE': 
              activateDrawTool(); 
              break;
            case 'DRAW_TOOL_DEACTIVATE': 
              deactivateDrawTool(); 
              break;
            case 'DRAW_TOOL_SET_COLOR': 
              setDrawToolColor(payload?.color || '#000000'); 
              break;
            case 'DRAW_TOOL_SET_WIDTH': 
              setDrawToolWidth(payload?.width || 5); 
              break;
            case 'UPDATE_OBJECT': updateSelectedObject(payload.property, payload.value); break;
            case 'NUDGE_POSITION': nudgePosition(payload.deltaX || 0, payload.deltaY || 0); break;
            case 'SET_SCALE': setScale(payload.scaleX || 1, payload.scaleY); break;
            case 'ROTATE_OBJECT': rotateObject(payload.angleDelta || 0); break;
            case 'SET_ZOOM': setCanvasZoom(payload.zoom); break;
            case 'ZOOM_IN': zoomIn(payload?.step); break;
            case 'ZOOM_OUT': zoomOut(payload?.step); break;
            case 'ALIGN_CENTER_H': alignCenterHorizontal(); break;
            case 'ALIGN_CENTER_V': alignCenterVertical(); break;
            case 'ALIGN_LEFT': alignLeft(); break;
            case 'ALIGN_RIGHT': alignRight(); break;
            case 'ALIGN_TOP': alignTop(); break;
            case 'ALIGN_BOTTOM': alignBottom(); break;
          case 'DELETE_SELECTED': deleteSelected(); break;
          case 'DUPLICATE_SELECTED': duplicateSelected(); break;
          case 'GROUP_SELECTED': groupSelected(); break;
          case 'UNGROUP_SELECTED': ungroupSelected(); break;
          case 'BRING_FORWARD': bringForward(); break;
          case 'SEND_BACKWARD': sendBackward(); break;
          case 'BRING_TO_FRONT': bringToFront(); break;
          case 'SEND_TO_BACK': sendToBack(); break;
          case 'SET_BACKGROUND': createBackground(payload.color); saveHistory(); break;
          case 'UNDO': undo(); break;
          case 'REDO': redo(); break;
          case 'EXPORT': exportCanvas(payload.format, payload.quality, payload.multiplier); break;
          case 'GET_LAYERS': getLayers(); break;
          case 'SET_LAYER_VISIBILITY': setLayerVisibility(payload.objectId, payload.visible); break;
          case 'SET_LAYER_LOCK': setLayerLock(payload.objectId, payload.locked); break;
          case 'SELECT_LAYER': selectLayer(payload.objectId); break;
          case 'SET_THEME': document.body.classList.toggle('dark', payload.dark); break;
          case 'DESELECT': canvas.discardActiveObject(); canvas.renderAll(); break;
          default: console.warn('Unknown message type:', type);
        }
        } catch(e) {
          console.error('Error handling message:', type, e);
        }
      };

      // Initialize when DOM ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCanvas);
      } else {
        initCanvas();
      }
    })();
  </script>
</body>
</html>


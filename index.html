<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Ghetch Logo Maker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #e5e7eb;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .dark {
      background: #1f1f1f;
    }
    .dark #canvas-wrapper {
      background: #2d2d2d;
    }
    .dark .checker { background-color: #3d3d3d; }

    #canvas-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      touch-action: none;
    }

    #canvas-wrapper {
      position: relative;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      overflow: hidden;
    }

    #canvas-wrapper.transparent-bg {
      background-image: 
        linear-gradient(45deg, #d1d5db 25%, transparent 25%),
        linear-gradient(-45deg, #d1d5db 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #d1d5db 75%),
        linear-gradient(-45deg, transparent 75%, #d1d5db 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    canvas { display: block; }

    #loading {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }

    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #d1d5db;
      border-top-color: #5956E9;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #status {
      margin-top: 16px;
      font-size: 13px;
      color: #6b7280;
    }

    .error {
      color: #ef4444 !important;
      text-align: center;
      padding: 0 20px;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div id="status">Initializing...</div>
  </div>
  
  <div id="canvas-container">
    <div id="canvas-wrapper">
      <canvas id="logo-canvas"></canvas>
    </div>
  </div>

  <!-- Load Fabric.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  
  <script>
    (function() {
      'use strict';

      const statusEl = document.getElementById('status');
      const loadingEl = document.getElementById('loading');

      function updateStatus(msg, isError) {
        statusEl.textContent = msg;
        if (isError) statusEl.classList.add('error');
        sendToRN({ type: 'STATUS', payload: { message: msg, isError } });
      }

      // Check if Fabric loaded
      if (typeof fabric === 'undefined') {
        updateStatus('Failed to load Fabric.js library', true);
        sendToRN({ type: 'LOAD_ERROR', payload: { error: 'Fabric.js not loaded' } });
        return;
      }

      updateStatus('Library loaded, initializing canvas...');

      let canvas = null;
      let historyStack = [];
      let historyIndex = -1;
      const MAX_HISTORY = 50;
      let backgroundRect = null;
      let canvasWidth = 280;
      let canvasHeight = 280;
      let currentZoom = 1;

      // Alignment & snapping guides
      const SNAP_THRESHOLD = 6; // px
      let hGuideLines = [];
      let vGuideLines = [];

      function initCanvas() {
        try {
          const container = document.getElementById('canvas-container');
          const wrapper = document.getElementById('canvas-wrapper');
          
          const maxWidth = container.clientWidth - 40;
          const maxHeight = container.clientHeight - 40;
          canvasWidth = Math.min(280, maxWidth);
          canvasHeight = Math.min(280, maxHeight);

          wrapper.style.width = canvasWidth + 'px';
          wrapper.style.height = canvasHeight + 'px';

          canvas = new fabric.Canvas('logo-canvas', {
            width: canvasWidth,
            height: canvasHeight,
            backgroundColor: '#ffffff',
            selection: true,
            preserveObjectStacking: true,
          });

          setupEventListeners();
          createBackground('#ffffff');
          saveHistory();

          loadingEl.classList.add('hidden');
          sendToRN({ type: 'CANVAS_READY', payload: { width: canvasWidth, height: canvasHeight } });
          
        } catch (error) {
          updateStatus('Error: ' + error.message, true);
          sendToRN({ type: 'LOAD_ERROR', payload: { error: error.message } });
        }
      }

      function setupEventListeners() {
        canvas.on('selection:created', handleSelection);
        canvas.on('selection:updated', handleSelection);
        canvas.on('selection:cleared', () => sendToRN({ type: 'SELECTION_CLEARED' }));
        canvas.on('object:modified', () => { 
          clearGuides();
          saveHistory(); 
          sendSelectionUpdate(); 
        });
        canvas.on('object:added', (e) => { if (e.target?.objectId !== 'background_layer') saveHistory(); });
        canvas.on('object:removed', (e) => { if (e.target?.objectId !== 'background_layer') saveHistory(); });
        canvas.on('object:moving', handleObjectMoving);
        canvas.on('mouse:up', clearGuides);
      }

      function createBackground(color) {
        if (backgroundRect) canvas.remove(backgroundRect);
        const wrapper = document.getElementById('canvas-wrapper');

        if (color === 'transparent') {
          wrapper.classList.add('transparent-bg');
          canvas.backgroundColor = 'transparent';
          backgroundRect = null;
        } else {
          wrapper.classList.remove('transparent-bg');
          backgroundRect = new fabric.Rect({
            left: 0, top: 0,
            width: canvasWidth, height: canvasHeight,
            fill: color,
            selectable: false, evented: false,
            objectId: 'background_layer',
          });
          canvas.add(backgroundRect);
          backgroundRect.sendToBack();
          canvas.backgroundColor = '#ffffff';
        }
        canvas.renderAll();
      }

      function addShape(type, options = {}) {
        let shape;
        const cx = canvasWidth / 2, cy = canvasHeight / 2;
        const defaults = { left: cx, top: cy, originX: 'center', originY: 'center', ...options };

        switch (type) {
          case 'rectangle':
            shape = new fabric.Rect({ ...defaults, width: 80, height: 80, fill: options.fill || '#3b82f6' });
            break;
          case 'circle':
            shape = new fabric.Circle({ ...defaults, radius: 40, fill: options.fill || '#10b981' });
            break;
          case 'triangle':
            shape = new fabric.Triangle({ ...defaults, width: 80, height: 80, fill: options.fill || '#f59e0b' });
            break;
          case 'line':
            shape = new fabric.Line([cx - 40, cy, cx + 40, cy], { stroke: options.stroke || '#000', strokeWidth: 3 });
            break;
          case 'star':
            const pts = [];
            for (let i = 0; i < 10; i++) {
              const r = i % 2 === 0 ? 40 : 20;
              const a = (Math.PI / 5) * i - Math.PI / 2;
              pts.push({ x: r * Math.cos(a), y: r * Math.sin(a) });
            }
            shape = new fabric.Polygon(pts, { ...defaults, fill: options.fill || '#8b5cf6' });
            break;
          case 'polygon':
            const sides = options.sides || 5, polyPts = [];
            for (let i = 0; i < sides; i++) {
              const a = (2 * Math.PI / sides) * i - Math.PI / 2;
              polyPts.push({ x: 40 * Math.cos(a), y: 40 * Math.sin(a) });
            }
            shape = new fabric.Polygon(polyPts, { ...defaults, fill: options.fill || '#ec4899' });
            break;
          default: return;
        }

        shape.objectId = 'shape_' + Date.now();
        shape.set({
          cornerColor: '#5956E9', cornerStrokeColor: '#5956E9', borderColor: '#5956E9',
          cornerSize: 10, cornerStyle: 'circle', transparentCorners: false, borderScaleFactor: 2,
        });
        canvas.add(shape);
        canvas.setActiveObject(shape);
        canvas.renderAll();
        sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(shape) });
      }

      function addText(text, options = {}) {
        const textObj = new fabric.IText(text || 'Your Text', {
          left: canvasWidth / 2, top: canvasHeight / 2,
          originX: 'center', originY: 'center',
          fontSize: options.fontSize || 32,
          fontFamily: options.fontFamily || 'Arial',
          fontWeight: options.fontWeight || 'normal',
          fill: options.fill || '#000000',
          textAlign: 'center',
          objectId: 'text_' + Date.now(),
          cornerColor: '#5956E9', cornerStrokeColor: '#5956E9', borderColor: '#5956E9',
          cornerSize: 10, cornerStyle: 'circle', transparentCorners: false,
        });
        canvas.add(textObj);
        canvas.setActiveObject(textObj);
        canvas.renderAll();
        sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(textObj) });
      }

      function addSVG(svgString) {
        fabric.loadSVGFromString(svgString, (objects, opts) => {
          const group = fabric.util.groupSVGElements(objects, opts);
          const scale = Math.min(80 / group.width, 80 / group.height);
          group.set({
            left: canvasWidth / 2, top: canvasHeight / 2,
            originX: 'center', originY: 'center',
            scaleX: scale, scaleY: scale,
            objectId: 'svg_' + Date.now(),
            cornerColor: '#5956E9', cornerStrokeColor: '#5956E9', borderColor: '#5956E9',
            cornerSize: 10, cornerStyle: 'circle', transparentCorners: false,
          });
          canvas.add(group);
          canvas.setActiveObject(group);
          canvas.renderAll();
          sendToRN({ type: 'OBJECT_ADDED', payload: getObjectInfo(group) });
        });
      }

      function updateSelectedObject(prop, val) {
        const obj = canvas.getActiveObject();
        if (!obj) return;
        if (prop === 'fontSize') val = parseInt(val);
        else if (prop === 'strokeWidth') val = parseFloat(val);
        obj.set(prop, val);
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function nudgePosition(deltaX, deltaY) {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        obj.set({ 
          left: obj.left + deltaX, 
          top: obj.top + deltaY 
        });
        obj.setCoords();
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function setScale(scaleX, scaleY) {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        obj.set({ 
          scaleX: scaleX, 
          scaleY: scaleY || scaleX 
        });
        obj.setCoords();
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      // Canvas zoom helpers
      function setCanvasZoom(zoom) {
        if (!canvas) return;
        const clamped = Math.max(0.5, Math.min(3, zoom || 1));
        const center = new fabric.Point(canvasWidth / 2, canvasHeight / 2);
        canvas.zoomToPoint(center, clamped);
        currentZoom = clamped;
        canvas.renderAll();
        sendToRN({ type: 'CANVAS_ZOOM', payload: { zoom: currentZoom } });
      }

      function zoomIn(step) {
        const delta = typeof step === 'number' ? step : 0.1;
        setCanvasZoom(currentZoom + delta);
      }

      function zoomOut(step) {
        const delta = typeof step === 'number' ? step : 0.1;
        setCanvasZoom(currentZoom - delta);
      }

      function rotateObject(angleDelta) {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        obj.set({ angle: (obj.angle || 0) + angleDelta });
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      // --- Alignment helpers (canvas center + snapping guides) ---

      function alignCenterHorizontal() {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        const center = obj.getCenterPoint();
        const newCenter = new fabric.Point(canvasWidth / 2, center.y);
        obj.setPositionByOrigin(newCenter, 'center', 'center');
        obj.setCoords();
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      function alignCenterVertical() {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        const center = obj.getCenterPoint();
        const newCenter = new fabric.Point(center.x, canvasHeight / 2);
        obj.setPositionByOrigin(newCenter, 'center', 'center');
        obj.setCoords();
        canvas.renderAll();
        saveHistory();
        sendSelectionUpdate();
      }

      // --- Snapping guides ---

      function clearGuides() {
        if (!canvas) return;
        const toRemove = canvas.getObjects().filter(o => o.isGuideLine);
        toRemove.forEach(o => canvas.remove(o));
        hGuideLines = [];
        vGuideLines = [];
        canvas.renderAll();
      }

      function addGuideLine(x1, y1, x2, y2, isVertical) {
        const line = new fabric.Line([x1, y1, x2, y2], {
          stroke: '#5956E9',
          strokeWidth: 1,
          selectable: false,
          evented: false,
          excludeFromExport: true,
          opacity: 0.6,
          strokeDashArray: [4, 4],
          isGuideLine: true,
        });
        canvas.add(line);
        if (isVertical) vGuideLines.push(line);
        else hGuideLines.push(line);
      }

      function handleObjectMoving(e) {
        const target = e.target;
        if (!target || target.objectId === 'background_layer') return;

        clearGuides();

        const center = target.getCenterPoint();
        let snapX = center.x;
        let snapY = center.y;

        const canvasCenterX = canvasWidth / 2;
        const canvasCenterY = canvasHeight / 2;

        // Snap to canvas center
        if (Math.abs(center.x - canvasCenterX) < SNAP_THRESHOLD) {
          snapX = canvasCenterX;
          addGuideLine(canvasCenterX, 0, canvasCenterX, canvasHeight, true);
        }
        if (Math.abs(center.y - canvasCenterY) < SNAP_THRESHOLD) {
          snapY = canvasCenterY;
          addGuideLine(0, canvasCenterY, canvasWidth, canvasCenterY, false);
        }

        // Snap to other object centers
        const objects = canvas.getObjects().filter(o => 
          o !== target && 
          o.objectId !== 'background_layer' && 
          !o.isGuideLine
        );

        objects.forEach(obj => {
          const c = obj.getCenterPoint();

          if (Math.abs(center.x - c.x) < SNAP_THRESHOLD) {
            snapX = c.x;
            addGuideLine(c.x, 0, c.x, canvasHeight, true);
          }
          if (Math.abs(center.y - c.y) < SNAP_THRESHOLD) {
            snapY = c.y;
            addGuideLine(0, c.y, canvasWidth, c.y, false);
          }
        });

        // Apply snapped center back to object position
        if (snapX !== center.x || snapY !== center.y) {
          target.setPositionByOrigin(
            new fabric.Point(snapX, snapY),
            'center',
            'center'
          );
          target.setCoords();
        }

        canvas.renderAll();
        sendSelectionUpdate();
      }

      function deleteSelected() {
        canvas.getActiveObjects().forEach(obj => {
          if (obj.objectId !== 'background_layer') canvas.remove(obj);
        });
        canvas.discardActiveObject();
        canvas.renderAll();
        saveHistory();
        sendToRN({ type: 'SELECTION_CLEARED' });
      }

      function duplicateSelected() {
        const obj = canvas.getActiveObject();
        if (!obj || obj.objectId === 'background_layer') return;
        obj.clone(cloned => {
          cloned.set({ left: obj.left + 15, top: obj.top + 15, objectId: obj.type + '_' + Date.now() });
          canvas.add(cloned);
          canvas.setActiveObject(cloned);
          canvas.renderAll();
          saveHistory();
        });
      }

      // Grouping helpers
      function groupSelected() {
        const activeObj = canvas.getActiveObject();
        if (!activeObj) return;

        // Fabric creates an ActiveSelection when multiple objects are selected
        if (activeObj.type === 'activeSelection') {
          const group = activeObj.toGroup();
          if (group) {
            // Ensure the group has a stable unique id so layer keys are unique
            if (!group.objectId) {
              group.objectId = 'group_' + Date.now();
            }
            // Ensure background stays at the very back
            if (backgroundRect) {
              backgroundRect.sendToBack();
            }
            canvas.renderAll();
            saveHistory();
            sendSelectionUpdate();
          }
        }
      }

      function ungroupSelected() {
        const activeObj = canvas.getActiveObject();
        if (!activeObj || activeObj.type !== 'group') return;

        const selection = activeObj.toActiveSelection();
        if (selection) {
          // Keep background behind everything
          if (backgroundRect) {
            backgroundRect.sendToBack();
          }
          canvas.renderAll();
          saveHistory();
          sendSelectionUpdate();
        }
      }

      function bringForward() { const o = canvas.getActiveObject(); if (o) { o.bringForward(); canvas.renderAll(); saveHistory(); } }
      function sendBackward() {
        const o = canvas.getActiveObject();
        if (o) {
          const objs = canvas.getObjects();
          const bgIdx = objs.findIndex(x => x.objectId === 'background_layer');
          if (objs.indexOf(o) > bgIdx + 1) { o.sendBackwards(); canvas.renderAll(); saveHistory(); }
        }
      }
      function bringToFront() { const o = canvas.getActiveObject(); if (o) { o.bringToFront(); canvas.renderAll(); saveHistory(); } }
      function sendToBack() {
        const o = canvas.getActiveObject();
        if (o) {
          o.sendToBack();
          if (backgroundRect) backgroundRect.sendToBack();
          canvas.renderAll();
          saveHistory();
        }
      }

      function saveHistory() {
        const json = canvas.toJSON(['objectId']);
        if (historyIndex < historyStack.length - 1) historyStack = historyStack.slice(0, historyIndex + 1);
        historyStack.push(json);
        if (historyStack.length > MAX_HISTORY) historyStack.shift();
        else historyIndex++;
        sendHistoryState();
      }

      function undo() { if (historyIndex > 0) { historyIndex--; loadHistory(); } }
      function redo() { if (historyIndex < historyStack.length - 1) { historyIndex++; loadHistory(); } }

      function loadHistory() {
        const state = historyStack[historyIndex];
        if (!state) return;
        canvas.loadFromJSON(state, () => {
          backgroundRect = canvas.getObjects().find(o => o.objectId === 'background_layer') || null;
          canvas.renderAll();
          sendHistoryState();
          sendToRN({ type: 'SELECTION_CLEARED' });
        });
      }

      function sendHistoryState() {
        sendToRN({ type: 'HISTORY_STATE', payload: { canUndo: historyIndex > 0, canRedo: historyIndex < historyStack.length - 1 } });
      }

      function exportCanvas(format, quality = 1, multiplier = 2) {
        try {
          if (format === 'svg') {
            sendToRN({ type: 'EXPORT_COMPLETE', payload: { format: 'svg', data: canvas.toSVG() } });
            return;
          }
          const dataUrl = canvas.toDataURL({ format: format === 'jpeg' ? 'jpeg' : 'png', quality, multiplier });
          sendToRN({ type: 'EXPORT_COMPLETE', payload: { format, data: dataUrl } });
        } catch (e) {
          sendToRN({ type: 'EXPORT_ERROR', payload: { error: e.message } });
        }
      }

      function getLayerName(obj) {
        if (obj.type === 'i-text' || obj.type === 'text' || obj.type === 'textbox') {
          return obj.text ? obj.text.substring(0, 20) : 'Text';
        }
        if (obj.type === 'rect' || obj.type === 'rectangle') return 'Rectangle';
        if (obj.type === 'circle') return 'Circle';
        if (obj.type === 'triangle') return 'Triangle';
        if (obj.type === 'line') return 'Line';
        if (obj.type === 'polygon') return 'Polygon';
        if (obj.type === 'group') return 'Group';
        if (obj.type === 'image') return 'Image';
        if (obj.type === 'path') return 'Path';
        return obj.type || 'Layer';
      }

      function getLayers() {
        const allObjects = canvas.getObjects().filter(o => o.objectId !== 'background_layer');
        const layers = allObjects
          .map((obj, i) => ({ 
            id: obj.objectId || ('layer_' + i), 
            type: obj.type, 
            name: getLayerName(obj),
            visible: obj.visible !== false, 
            locked: !obj.selectable, 
            index: allObjects.length - i - 1
          }))
          .reverse();
        sendToRN({ type: 'LAYERS_LIST', payload: { layers } });
      }

      function setLayerVisibility(id, visible) {
        const obj = canvas.getObjects().find(o => o.objectId === id);
        if (obj) { obj.set('visible', visible); canvas.renderAll(); saveHistory(); }
      }

      function setLayerLock(id, locked) {
        const obj = canvas.getObjects().find(o => o.objectId === id);
        if (obj && obj.objectId !== 'background_layer') {
          obj.set({ selectable: !locked, evented: !locked });
          canvas.renderAll();
          saveHistory();
        }
      }

      function selectLayer(id) {
        const obj = canvas.getObjects().find(o => o.objectId === id);
        if (obj && obj.selectable) { canvas.setActiveObject(obj); canvas.renderAll(); }
      }

      function handleSelection(e) {
        const sel = e.selected[0];
        if (sel && sel.objectId !== 'background_layer') {
          sendToRN({ type: 'SELECTION_CHANGED', payload: getObjectInfo(sel) });
        }
      }

      function sendSelectionUpdate() {
        const obj = canvas.getActiveObject();
        if (obj && obj.objectId !== 'background_layer') {
          sendToRN({ type: 'SELECTION_CHANGED', payload: getObjectInfo(obj) });
        }
      }

      function getObjectInfo(obj) {
        return {
          objectId: obj.objectId, type: obj.type,
          left: Math.round(obj.left), top: Math.round(obj.top),
          width: Math.round(obj.width * (obj.scaleX || 1)),
          height: Math.round(obj.height * (obj.scaleY || 1)),
          scaleX: obj.scaleX || 1,
          scaleY: obj.scaleY || 1,
          angle: Math.round(obj.angle || 0),
          fill: obj.fill, stroke: obj.stroke, strokeWidth: obj.strokeWidth, opacity: obj.opacity,
          text: obj.text, fontSize: obj.fontSize, fontFamily: obj.fontFamily, fontWeight: obj.fontWeight,
        };
      }

      function sendToRN(msg) {
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify(msg));
        } else {
          console.log('RN Message:', msg);
        }
      }

      window.handleRNMessage = function(message) {
        try {
          const { type, payload } = typeof message === 'string' ? JSON.parse(message) : message;
          switch (type) {
            case 'ADD_SHAPE': addShape(payload.shape, payload.options); break;
            case 'ADD_TEXT': addText(payload.text, payload.options); break;
            case 'ADD_SVG': addSVG(payload.svg); break;
            case 'UPDATE_OBJECT': updateSelectedObject(payload.property, payload.value); break;
            case 'NUDGE_POSITION': nudgePosition(payload.deltaX || 0, payload.deltaY || 0); break;
            case 'SET_SCALE': setScale(payload.scaleX || 1, payload.scaleY); break;
            case 'ROTATE_OBJECT': rotateObject(payload.angleDelta || 0); break;
            case 'SET_ZOOM': setCanvasZoom(payload.zoom); break;
            case 'ZOOM_IN': zoomIn(payload?.step); break;
            case 'ZOOM_OUT': zoomOut(payload?.step); break;
            case 'ALIGN_CENTER_H': alignCenterHorizontal(); break;
            case 'ALIGN_CENTER_V': alignCenterVertical(); break;
          case 'DELETE_SELECTED': deleteSelected(); break;
          case 'DUPLICATE_SELECTED': duplicateSelected(); break;
          case 'GROUP_SELECTED': groupSelected(); break;
          case 'UNGROUP_SELECTED': ungroupSelected(); break;
          case 'BRING_FORWARD': bringForward(); break;
          case 'SEND_BACKWARD': sendBackward(); break;
          case 'BRING_TO_FRONT': bringToFront(); break;
          case 'SEND_TO_BACK': sendToBack(); break;
          case 'SET_BACKGROUND': createBackground(payload.color); saveHistory(); break;
          case 'UNDO': undo(); break;
          case 'REDO': redo(); break;
          case 'EXPORT': exportCanvas(payload.format, payload.quality, payload.multiplier); break;
          case 'GET_LAYERS': getLayers(); break;
          case 'SET_LAYER_VISIBILITY': setLayerVisibility(payload.objectId, payload.visible); break;
          case 'SET_LAYER_LOCK': setLayerLock(payload.objectId, payload.locked); break;
          case 'SELECT_LAYER': selectLayer(payload.objectId); break;
          case 'SET_THEME': document.body.classList.toggle('dark', payload.dark); break;
          case 'DESELECT': canvas.discardActiveObject(); canvas.renderAll(); break;
          default: console.warn('Unknown message type:', type);
        }
        } catch(e) {
          console.error('Error handling message:', type, e);
        }
      };

      // Initialize when DOM ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCanvas);
      } else {
        initCanvas();
      }
    })();
  </script>
</body>
</html>

